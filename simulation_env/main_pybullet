import pybullet as pb
import pybullet_data
import random as rnd
import assisting_functions as af
import time

#initializes the simulation with standard conditions
#the environment includes a plane(ground/fixed) and gravity
#also defines if GUI is to be used or not
def sim_init(GUI=False, gravity = -9.81):
    if GUI == False:
        pb.connect(pb.direct)
    else:
        pb.connect(pb.GUI)
    
    #set gravity
    pb.setGravity(0,0,gravity)
    
    #advanced settings
    #pb.setAdditionalSearchPath(pybullet_data.getDataPath())
    assets_folder = "C:/Users/diogo serra/Desktop/trabalhos, documentose afixos de programas/TUDelft-MEaer/een/even semester/AI/Bipedal agent project/simulation_env/assets"
    pb.setAdditionalSearchPath(assets_folder)
    print(pybullet_data.getDataPath())
    
    #create physical environment
    planeId = pb.loadURDF("plane.urdf", useFixedBase=True) 
    
    return planeId

#MAIN SIMULATION CONTROL LOOP, EDIT HERE WHAT TO DO
#[!] time controlled simulations do not discount time spent on computations as opposed to time spent in stepping
#this is because this is a debug feature anyways and won't be used in the final version
def sim_loop(robot_list ,time_controlled=True, limit_time = 5, step_limit = 1000):  
    
    ######################## TIME CONTROLLED ########################
    
    #run time controlled/limited (will run forever until GUI is closed)
    #uses limit time (in seconds) to stop simulation
    if time_controlled:
        
        #sets simulation to use real time
        pb.setRealTimeSimulation(1)
        
        clock_start = time.time()
        elapsed_time = 0
        while True:    
            #WRITE FUNCTIONS TO RUN IN CODE HERE!!!
            
            
            
            #check if time limit has been reached
            elapsed_time = time.time() - clock_start
            if elapsed_time > limit_time:
                break
            pass
        
    
    ######################## STEP CONTROLLED ########################
        
    #run without GUI and step-by-step limited (will run for simulation time and is limited by processing power)
    #needs a step limit, else it will assume one
    elif not time_controlled:

        #step once to begin simulation, but define first step as step 0
        pb.stepSimulation()
        for step in range(step_limit):
            
            #WRITE FUNCTIONS TO RUN IN CODE HERE!!!
            
            
            
            #step simulation
            pb.stepSimulation()
    pass

#creates a new robot in the simulation
#robot_ID needs to be supplied or else it will be set to a random value
#robot list is a dictionary with the Robots_ID as keys and the robot object as values
def create_robot(robot_ID=-1,robot_list={},robot_type = "biped_norotation.urdf"):
    
    #handle the ID of the robot
    if robot_ID == -1:
        robot_ID = "RND_" + str(rnd.uniform(0,1000))
        
    #get a starting position for the robot
    #for that we need to know how many robots are already in the simulation
    #z spacing of 1.1 matches roughly the height of the robot
    #2 [unit] is roughly enough spacing between 2 robots
    robot_count = len(robot_list)
    starting_pos = [len(robot_list),0,1.1]
    starting_orientation = pb.getQuaternionFromEuler([0,0,0])
    
    #create the robot
    robot = pb.loadURDF(robot_type, starting_pos, starting_orientation, useFixedBase=False)
    
    #relax the muscles/define standard friction
    #must not be 0
    jointFrictionForce = 10
    for joint in range(pb.getNumJoints(robot)):
        pb.setJointMotorControl2(robot, joint, pb.POSITION_CONTROL, force=jointFrictionForce)
        
    #reference joints should be set at 0
    #this makes it so they dont oppose movement as they are simply plane constraints
    pb.setJointMotorControl2(robot, 0,  pb.POSITION_CONTROL, force=0) #origin to z
    pb.setJointMotorControl2(robot, 1,  pb.POSITION_CONTROL, force=0) #z to x
    pb.setJointMotorControl2(robot, 2,  pb.POSITION_CONTROL, force=0) #x to y
        
    #append to dictionary
    robot_list.update({robot_ID: robot})
    
    return robot_list

